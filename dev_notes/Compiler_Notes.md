[](...menustart)

- [Compiler Note](#e2028ec0b6d18c6dc1518b1218fe67e9)
- [Introduction](#0b79795d3efc95b9976c7c5b933afce2)
    - [lexical analysis ，or scanning](#19d107f572eb681d34f40cde481b4468)
    - [Syntax analysis ,  or parsing](#ec681573771e1e3fb7e7c285b64847f6)
        - [Concrete syntax tree](#e0b53b573761582598d1a195e4ac1ce7)
        - [(abstract) syntax tree](#e3ae6ba0b6984fbc4fd3a4c211a567d2)
        - [Precedence of Operators 操作符优先级](#33cf9420c47bd66697f4b0d8ff143901)
        - [syntax-directed translation (SDT)](#c496fb929875aa957c91118cbbd9d2d0)
            - [Syntax-directed definition](#d8eb8df3e127bc91356f655467013119)
            - [Syntax-directed Translation Schemes](#6261c2c3983122039f48b1eb1b3e06a4)
        - [Parsing](#8b08e51f06fabcbfa16942fbff59ab29)
            - [Top-Down Parsing](#e10c5506cd3ee1526ab22ec45ed61cad)
            - [Bottom-up Parsing](#0e793c03a59ad4fe7a3a95bc1eac783d)
            - [Predictive Parsing](#7fdb4425ae20f138f82d1c89cfe8d5bf)
    - [Semantic analysis](#0eb1784eda9b81e0d55b27d4f8cb46d3)
    - [Intermediate code generation](#81862566cf2fdc0d212a8dd1d169dc90)
    - [Code optimize](#ae0b27365844a81d865ccbc6516f84ec)
    - [Code generation](#43dbed76634f46606bc217bd2f6f4c2c)

[](...menuend)


<h2 id="e2028ec0b6d18c6dc1518b1218fe67e9"></h2>

# Compiler Note

<h2 id="0b79795d3efc95b9976c7c5b933afce2"></h2>

# Introduction

2 parts of compiler : analysis / synthesis


<h2 id="19d107f572eb681d34f40cde481b4468"></h2>

## lexical analysis ，or scanning 

- tokens and symbol table

<h2 id="ec681573771e1e3fb7e7c285b64847f6"></h2>

## Syntax analysis ,  or parsing

- syntax describes the proper form of its programs
- use context-free grammars to specify the syntax of a language
    - CFG itself is specified by listing their productions.
    - Parser的任务是 find a parse tree for a given string of terminals

<h2 id="e0b53b573761582598d1a195e4ac1ce7"></h2>

### Concrete syntax tree 

- derivation 的过程
    - root  -- start symbol
    - interior node -- nonterminal
        - correspond to a production with its children
    - leaf  --  terminal or eps
        - from left to right, the leaves form the *yield* of the tree

- **CST 其实就是 parse tree**。
- CST只是概念上的语法术，大部分编译器都使用AST。        

<h2 id="e3ae6ba0b6984fbc4fd3a4c211a567d2"></h2>

### (abstract) syntax tree

- interior --  an operator
- children of the node -- the operands of the operator
- AST 是一种数据结构

<h2 id="33cf9420c47bd66697f4b0d8ff143901"></h2>

### Precedence of Operators 操作符优先级

- Idea to any number n of precedence levels
    - We need *n+1* nonterminals.
    - The first,like *factor* , can never be torn apart.
    - Then, for each precedence level, there is one *nonterminal* representing expressions that can be torn apart only by ***operators at that level or higher***

<h2 id="c496fb929875aa957c91118cbbd9d2d0"></h2>

### syntax-directed translation (SDT)

- 将输入的字符串翻译成一些列具有语义的动作
- SDT is done by attaching rules or program fragments to productions in a grammar.

---

<h2 id="d8eb8df3e127bc91356f655467013119"></h2>

#### Syntax-directed definition

- SDD是特殊的CFG , 特殊之处在于:
    - We associate attributes with ***nonterminals and terminals***. 
    - Then, we attach rules to the ***productions*** of the grammar; 


PRODUCTION | SEMANTIC RULES
--- | ---
expr → expr₁ + term | expr.t = expr₁.t ‖ term.t ‖ '+' 

<h2 id="6261c2c3983122039f48b1eb1b3e06a4"></h2>

#### Syntax-directed Translation Schemes

- SDTS 也是一种特殊的CFG
    - it attachs program fragments to productions in a grammar.
- SDTS 和 SDD 相似，SDD指定语义动作，SDTS实现了这些语义动作。 ??

```
expr → expr₁ + term  {print('+')}
expr → expr₁ - term  {print('-')} 
expr → term
term → 0             {print('0')}
```


<h2 id="8b08e51f06fabcbfa16942fbff59ab29"></h2>

### Parsing 

- Parsing is the process of determining how a string of terminals can be generated by a grammar.
- "recursive descent" method can be used both to parse and to implement syntax-directed translators.
- **Yacc** is a alternative tool 
    - to generate a translator directly from a translation scheme


<h2 id="e10c5506cd3ee1526ab22ec45ed61cad"></h2>

#### Top-Down Parsing

- 可以较容易地手工构造出高效的语法分析器

<h2 id="0e793c03a59ad4fe7a3a95bc1eac783d"></h2>

#### Bottom-up Parsing
 
- can handle a larger class of grammars and translation schemes
   - software tools for generating parsers directly from grammars often use bottom-up methods.

<h2 id="7fdb4425ae20f138f82d1c89cfe8d5bf"></h2>

#### Predictive Parsing

- a simple form of recursive-descent parsing
    - the lookahead symbol unambiguously determines the flow of control
- is a program consisting of a procedure for every nonterminal
- FIRST(α) 


---

<h2 id="0eb1784eda9b81e0d55b27d4f8cb46d3"></h2>

## Semantic analysis

- semantic define what its programs mean
- gather type info
- type checking
- coercions

<h2 id="81862566cf2fdc0d212a8dd1d169dc90"></h2>

## Intermediate code generation

- AST -> three-address code



--- analysis end ---

<h2 id="ae0b27365844a81d865ccbc6516f84ec"></h2>

## Code optimize

<h2 id="43dbed76634f46606bc217bd2f6f4c2c"></h2>

## Code generation

---------
 

    






 
